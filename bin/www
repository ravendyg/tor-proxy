#!/usr/bin/env node

/**
 * Module dependencies.
 */

const cluster = require('cluster');
const exec = require('child_process').exec;
const fs = require('fs');
const path = require('path');

const proxy = require('../lib/proxy');
const config = require('../lib/config');
const utils = require('../lib/utils');


const workers = {};


if (cluster.isMaster) {

  const rootDir = path.join(__dirname, '..');
  const torDir = path.join(rootDir, 'tor');
  const dataDir = path.join(torDir, 'data-dir');

  if (!fs.existsSync(torDir)) {
    fs.mkdirSync(torDir);
  }
  if (!fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir);
  }

  const files = fs.readdirSync(torDir)
    .filter(e => /torrc\.[0-9]{1,2}/.test(e));
  for (let file of files) {
    fs.unlinkSync(path.join(torDir, file));
  }

  exec('ps aux | grep ./tor/torrc.', function cb(err, stdout, stderr) {
    if (err) {
      console.error(utils.logDate(), err);
    } else if (stderr) {
      console.error(utils.logDate(), stderr);
    } else {
      let tasks = stdout.split('\n');
      let torInstances =
        tasks
        .filter(e => e.match(/\.\/tor\/torrc\.[0-9]/))
        .map(e => e.match(/\S+/g)[1])
        ;
      for (let instance of torInstances) {
        exec('kill -9 ' + instance);
      }
      for (let i = 0; i < config.NUMBER_OF_TOR_INSTANCES; i++) {
        startWorker(i, config.SPAWN_ATTEMPTS);
      }

      let restarting = 0;
      setInterval(function restart() {
        workers[restarting].send({action: 'close', id: restarting});
        if (++restarting >= config.NUMBER_OF_TOR_INSTANCES) {
          restarting = 0;
        }
      }, config.RESTART_PERIOD);
    }
  });

} else {
  process.on('message', msg => {

    if (msg.type === 'run') {
      proxy.start(msg.id).then(() => {

        var app = require('../app');
        var http = require('http');

        /**
         * Get port from environment and store in Express.
         */

        var port = normalizePort(config.PORT);
        app.set('port', port);

        /**
         * Create HTTP server.
         */

        var server = http.createServer(app);

        /**
         * Listen on provided port, on all network interfaces.
         */

        server.listen(port);
        server.on('error', onError);

        /**
         * Normalize a port into a number, string, or false.
         */

        function normalizePort(val) {
          var _port = parseInt(val, 10);

          if (isNaN(_port)) {
            // named pipe
            return val;
          }

          if (_port >= 0) {
            // port number
            return _port;
          }

          return false;
        }

        /**
         * Event listener for HTTP server "error" event.
         */

        function onError(error) {
          if (error.syscall !== 'listen') {
            throw error;
          }

          var bind = typeof port === 'string'
            ? 'Pipe ' + port
            : 'Port ' + port;

          // handle specific listen errors with friendly messages
          switch (error.code) {
            case 'EACCES':
              console.error(bind + ' requires elevated privileges');
              process.exit(1);
              break;
            case 'EADDRINUSE':
              console.error(bind + ' is already in use');
              process.exit(1);
              break;
            default:
              throw error;
          }
        }
      });
    }
  });
}


function startWorker(id, restartsLeft) {
  const worker = cluster.fork();
  workers[id] = worker;

  worker.on('exit', code => {
    if (code !== 0) {
      restartsLeft--;
      if (restartsLeft > 0) {
        startWorker(id, restartsLeft);
      } else {
        console.error(id + ' exceeded restart limit');
      }
    }
  });

  worker.on('message', msg => {
    if (msg.action === 'close') {
      startWorker(msg.id, config.SPAWN_ATTEMPTS);
    }
  });

  worker.send({
    type: 'run',
    id
  });
}
